# Cline Custom Instructions for KAST-Web Project

## Project Context
This is the KAST-Web project - a Flask-based web interface for security scanning with Celery async task processing, comprehensive user authentication, role-based access control, email notifications, scan sharing, logo white-labeling, and extensive admin controls.

## Primary Instruction
Before working on any task, always review the comprehensive project documentation in `genai-instructions.md`. This file contains:
- Project architecture and structure
- Code standards and conventions
- Database models and relationships
- Authentication/authorization patterns
- Development workflow
- Common pitfalls and solutions
- Best practices specific to this project

## Database Models Overview
The project uses 7 main SQLAlchemy models in `app/models.py`:
1. **User** - Authentication, roles (admin/power_user/user/viewer), login tracking
2. **Scan** - Scan configuration, status, results, logo association, source tracking
3. **ScanResult** - Individual plugin results per scan
4. **AuditLog** - Security audit trail for all sensitive actions
5. **ScanShare** - Scan sharing (user-to-user and public links with expiration)
6. **ReportLogo** - Custom logo uploads for white-labeled reports
7. **SystemSettings** - Key-value store for system configuration (SMTP, maintenance mode, etc.)

## Role-Based Access Control
Four user roles with distinct permissions:
- **admin**: Full system access, user management, admin panel, database explorer, all scans
- **power_user**: Can run active scans, manage own scans, share scans, upload logos
- **user**: Can run passive scans only, manage own scans, share scans, basic features
- **viewer**: Read-only access to shared scans, cannot create/modify scans

Key permission methods:
- `current_user.is_admin` - Check admin role
- `current_user.is_power_user` - Check power user role
- `current_user.can_run_active_scans` - Check if user can run active scans (admin/power_user)

## Key Reminders
- Follow PEP 8 style guidelines (4 spaces, snake_case for functions, PascalCase for classes)
- Use SQLAlchemy ORM patterns (never raw SQL except in admin database explorer)
- Always include `@login_required` and permission checks for protected routes
- Use `@admin_required` or `@power_user_required` decorators from `app/utils.py` when needed
- Log sensitive actions to AuditLog model using `AuditLog.log()` static method
- Test with Celery worker running for any scan-related or email features
- Create migration scripts in `utils/` for database schema changes
- Update documentation when adding/changing features (README.md, genai-instructions.md, docs/)
- Follow existing patterns in similar files before creating new approaches
- Check SystemSettings for feature toggles (email_enabled, maintenance_mode, etc.)

## Feature-Specific Patterns

### Email System
- SMTP configuration stored in SystemSettings (smtp_host, smtp_port, use_tls, etc.)
- Email sending is async via Celery (`send_report_email_task.delay()`)
- Always validate email addresses with `email_validator` library
- Check `SystemSettings.get_setting('email_enabled')` before sending
- Test SMTP connection before enabling email functionality
- Log email actions to AuditLog

### Scan Sharing
- Two types: user-to-user (`shared_with_user_id` set) and public links (NULL user_id)
- Public shares use unique tokens generated by `ScanShare.generate_token()`
- Check expiration with `share.is_expired()`
- Verify access before allowing scan viewing
- Permission levels: 'view' or 'edit'
- Log share creation to AuditLog

### Logo White-Labeling
- Logos stored in `app/static/uploads/logos/`
- ReportLogo model tracks uploads with metadata
- Scans have optional `logo_id` field (NULL = system default)
- Validate file types (image formats only) and size limits
- Use unique filenames to prevent collisions
- Log logo uploads to AuditLog

### System Settings
- Use `SystemSettings.get_setting(key, default)` to retrieve settings
- Use `SystemSettings.set_setting(key, value, value_type, user_id)` to update
- Support types: 'string', 'int', 'bool', 'json'
- Common settings: maintenance_mode, email_enabled, smtp_*, from_email, from_name
- Always log settings changes to AuditLog

### Maintenance Mode
- When enabled, blocks all non-admin users except auth routes
- Check in `@app.before_request` handler
- Can be toggled via admin panel or direct database update
- Admins always have access to disable it

### CLI Import Feature
- Scans can have `source` field: 'web' (GUI) or 'imported' (CLI)
- Imported scans may have pre-existing results and files
- Check `execution_log_path` for full KAST execution logs
- Follow import patterns in `app/import_utils.py`

## File References
When unsure about implementation details, refer to:
- `genai-instructions.md` - Complete project guidelines (comprehensive reference)
- `README.md` - Project overview and setup
- `app/models.py` - Database schema and all 7 models
- `app/utils.py` - Helper functions and decorators
- `app/email.py` - Email utilities and SMTP handling
- `app/import_utils.py` - CLI import handling
- `config.py` - Configuration patterns
- Existing route files in `app/routes/` for route patterns

## Documentation Structure
Feature-specific documentation in `docs/`:
- `EMAIL_FEATURE.md` / `EMAIL_QUICK_START.md` - Email system
- `SHARING_PHASE4_COMPLETE.md` - Scan sharing
- `LOGO_WHITELABELING_FEATURE.md` / `LOGO_FEATURE_QUICK_START.md` - Logo system
- `ADMIN_PANEL_PHASE3.md` - Admin panel features
- `POWER_USER_FEATURE.md` - Power user role
- `DATABASE_EXPLORER_FEATURE.md` - Database explorer
- `MAINTENANCE_MODE_ENFORCEMENT.md` - Maintenance mode
- `AUTHORIZATION_PHASE2.md` - Authorization system
- `CLI_IMPORT_FEATURE.md` / `CLI_IMPORT_QUICK_START.md` - CLI import
- `PRODUCTION_DEPLOYMENT.md` - Production setup
- `ASYNC_SETUP.md` - Celery/async configuration

## Critical Constraints
- Celery worker must be running for scans and emails to execute
- Redis must be running as Celery message broker
- KAST CLI tool must be installed at configured path
- SMTP must be configured and tested for email functionality
- Proper file permissions for database, results, and upload directories
- Always use `@login_required` for protected routes
- Always check user permissions before allowing data access
- Always log sensitive actions to AuditLog
- Use HTTPS in production with strong SECRET_KEY
- Backup database before using admin database explorer
- Migration scripts required for all schema changes

## Common Pitfalls
- Forgetting to check `can_run_active_scans` for active scan mode
- Not validating share access before displaying scans
- Missing AuditLog entries for sensitive actions
- Not checking SystemSettings for feature toggles
- Forgetting to handle scan sharing in permission checks
- Not checking maintenance mode status
- Missing email validation before sending
- Not handling expired shares properly
- Forgetting logo_id can be NULL (use system default)
- Not distinguishing between 'web' and 'imported' scan sources
